Terminals which are not used

   ASSIGN
   ADD_ASSIGN
   SUB_ASSIGN
   MUL_ASSIGN
   DIV_ASSIGN
   MOD_ASSIGN
   EQUAL
   NOTEQUAL
   INC
   DEC
   GT
   GE
   LT
   LE
   LSHIFT
   RSHIFT
   NOT
   IDENT


Grammar

    0 $accept: program $end

    1 program: expression

    2 expression: primary
    3           | expression ADD expression
    4           | expression SUB expression
    5           | expression MUL expression
    6           | expression DIV expression
    7           | expression MOD expression
    8           | expression BIT_OR expression
    9           | expression BIT_AND expression
   10           | expression LOGIC_OR expression
   11           | expression LOGIC_AND expression
   12           | LP expression RP

   13 primary: INT
   14        | DOUBLE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT (258) 13
DOUBLE (259) 14
ADD (260) 3
SUB (261) 4
MUL (262) 5
DIV (263) 6
MOD (264) 7
ASSIGN (265)
ADD_ASSIGN (266)
SUB_ASSIGN (267)
MUL_ASSIGN (268)
DIV_ASSIGN (269)
MOD_ASSIGN (270)
EQUAL (271)
NOTEQUAL (272)
INC (273)
DEC (274)
GT (275)
GE (276)
LT (277)
LE (278)
LSHIFT (279)
RSHIFT (280)
NOT (281)
BIT_AND (282) 9
BIT_OR (283) 8
LOGIC_AND (284) 11
LOGIC_OR (285) 10
LP (286) 12
RP (287) 12
IDENT (288)


Nonterminals, with rules where they appear

$accept (34)
    on left: 0
program (35)
    on left: 1, on right: 0
expression (36)
    on left: 2 3 4 5 6 7 8 9 10 11 12, on right: 1 3 4 5 6 7 8 9 10
    11 12
primary (37)
    on left: 13 14, on right: 2


state 0

    0 $accept: . program $end
    1 program: . expression
    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    program     go to state 4
    expression  go to state 5
    primary     go to state 6


state 1

   13 primary: INT .

    $default  reduce using rule 13 (primary)


state 2

   14 primary: DOUBLE .

    $default  reduce using rule 14 (primary)


state 3

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   12           | LP . expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 7
    primary     go to state 6


state 4

    0 $accept: program . $end

    $end  shift, and go to state 8


state 5

    1 program: expression .  [$end]
    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    ADD        shift, and go to state 9
    SUB        shift, and go to state 10
    MUL        shift, and go to state 11
    DIV        shift, and go to state 12
    MOD        shift, and go to state 13
    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 1 (program)


state 6

    2 expression: primary .

    $default  reduce using rule 2 (expression)


state 7

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression
   12           | LP expression . RP

    ADD        shift, and go to state 9
    SUB        shift, and go to state 10
    MUL        shift, and go to state 11
    DIV        shift, and go to state 12
    MOD        shift, and go to state 13
    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17
    RP         shift, and go to state 18


state 8

    0 $accept: program $end .

    $default  accept


state 9

    2 expression: . primary
    3           | . expression ADD expression
    3           | expression ADD . expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 19
    primary     go to state 6


state 10

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    4           | expression SUB . expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 20
    primary     go to state 6


state 11

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    5           | expression MUL . expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 21
    primary     go to state 6


state 12

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    6           | expression DIV . expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 22
    primary     go to state 6


state 13

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    7           | expression MOD . expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 23
    primary     go to state 6


state 14

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
    9           | expression BIT_AND . expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 24
    primary     go to state 6


state 15

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    8           | expression BIT_OR . expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 25
    primary     go to state 6


state 16

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   11           | . expression LOGIC_AND expression
   11           | expression LOGIC_AND . expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 26
    primary     go to state 6


state 17

    2 expression: . primary
    3           | . expression ADD expression
    4           | . expression SUB expression
    5           | . expression MUL expression
    6           | . expression DIV expression
    7           | . expression MOD expression
    8           | . expression BIT_OR expression
    9           | . expression BIT_AND expression
   10           | . expression LOGIC_OR expression
   10           | expression LOGIC_OR . expression
   11           | . expression LOGIC_AND expression
   12           | . LP expression RP
   13 primary: . INT
   14        | . DOUBLE

    INT     shift, and go to state 1
    DOUBLE  shift, and go to state 2
    LP      shift, and go to state 3

    expression  go to state 27
    primary     go to state 6


state 18

   12 expression: LP expression RP .

    $default  reduce using rule 12 (expression)


state 19

    3 expression: expression . ADD expression  [$end, ADD, SUB, RP]
    3           | expression ADD expression .  [$end, ADD, SUB, RP]
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    MUL        shift, and go to state 11
    DIV        shift, and go to state 12
    MOD        shift, and go to state 13
    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 3 (expression)

    Conflict between rule 3 and token ADD resolved as reduce (%left ADD).
    Conflict between rule 3 and token SUB resolved as reduce (%left SUB).
    Conflict between rule 3 and token MUL resolved as shift (ADD < MUL).
    Conflict between rule 3 and token DIV resolved as shift (ADD < DIV).
    Conflict between rule 3 and token MOD resolved as shift (ADD < MOD).
    Conflict between rule 3 and token BIT_AND resolved as shift (ADD < BIT_AND).
    Conflict between rule 3 and token BIT_OR resolved as shift (ADD < BIT_OR).
    Conflict between rule 3 and token LOGIC_AND resolved as shift (ADD < LOGIC_AND).
    Conflict between rule 3 and token LOGIC_OR resolved as shift (ADD < LOGIC_OR).


state 20

    3 expression: expression . ADD expression
    4           | expression . SUB expression  [$end, ADD, SUB, RP]
    4           | expression SUB expression .  [$end, ADD, SUB, RP]
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    MUL        shift, and go to state 11
    DIV        shift, and go to state 12
    MOD        shift, and go to state 13
    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 4 (expression)

    Conflict between rule 4 and token ADD resolved as reduce (%left ADD).
    Conflict between rule 4 and token SUB resolved as reduce (%left SUB).
    Conflict between rule 4 and token MUL resolved as shift (SUB < MUL).
    Conflict between rule 4 and token DIV resolved as shift (SUB < DIV).
    Conflict between rule 4 and token MOD resolved as shift (SUB < MOD).
    Conflict between rule 4 and token BIT_AND resolved as shift (SUB < BIT_AND).
    Conflict between rule 4 and token BIT_OR resolved as shift (SUB < BIT_OR).
    Conflict between rule 4 and token LOGIC_AND resolved as shift (SUB < LOGIC_AND).
    Conflict between rule 4 and token LOGIC_OR resolved as shift (SUB < LOGIC_OR).


state 21

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    5           | expression MUL expression .  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 5 (expression)

    Conflict between rule 5 and token ADD resolved as reduce (ADD < MUL).
    Conflict between rule 5 and token SUB resolved as reduce (SUB < MUL).
    Conflict between rule 5 and token MUL resolved as reduce (%left MUL).
    Conflict between rule 5 and token DIV resolved as reduce (%left DIV).
    Conflict between rule 5 and token MOD resolved as reduce (%left MOD).
    Conflict between rule 5 and token BIT_AND resolved as shift (MUL < BIT_AND).
    Conflict between rule 5 and token BIT_OR resolved as shift (MUL < BIT_OR).
    Conflict between rule 5 and token LOGIC_AND resolved as shift (MUL < LOGIC_AND).
    Conflict between rule 5 and token LOGIC_OR resolved as shift (MUL < LOGIC_OR).


state 22

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    6           | expression DIV expression .  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 6 (expression)

    Conflict between rule 6 and token ADD resolved as reduce (ADD < DIV).
    Conflict between rule 6 and token SUB resolved as reduce (SUB < DIV).
    Conflict between rule 6 and token MUL resolved as reduce (%left MUL).
    Conflict between rule 6 and token DIV resolved as reduce (%left DIV).
    Conflict between rule 6 and token MOD resolved as reduce (%left MOD).
    Conflict between rule 6 and token BIT_AND resolved as shift (DIV < BIT_AND).
    Conflict between rule 6 and token BIT_OR resolved as shift (DIV < BIT_OR).
    Conflict between rule 6 and token LOGIC_AND resolved as shift (DIV < LOGIC_AND).
    Conflict between rule 6 and token LOGIC_OR resolved as shift (DIV < LOGIC_OR).


state 23

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    7           | expression MOD expression .  [$end, ADD, SUB, MUL, DIV, MOD, RP]
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    BIT_AND    shift, and go to state 14
    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 7 (expression)

    Conflict between rule 7 and token ADD resolved as reduce (ADD < MOD).
    Conflict between rule 7 and token SUB resolved as reduce (SUB < MOD).
    Conflict between rule 7 and token MUL resolved as reduce (%left MUL).
    Conflict between rule 7 and token DIV resolved as reduce (%left DIV).
    Conflict between rule 7 and token MOD resolved as reduce (%left MOD).
    Conflict between rule 7 and token BIT_AND resolved as shift (MOD < BIT_AND).
    Conflict between rule 7 and token BIT_OR resolved as shift (MOD < BIT_OR).
    Conflict between rule 7 and token LOGIC_AND resolved as shift (MOD < LOGIC_AND).
    Conflict between rule 7 and token LOGIC_OR resolved as shift (MOD < LOGIC_OR).


state 24

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, RP]
    9           | expression BIT_AND expression .  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, RP]
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    BIT_OR     shift, and go to state 15
    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 9 (expression)

    Conflict between rule 9 and token ADD resolved as reduce (ADD < BIT_AND).
    Conflict between rule 9 and token SUB resolved as reduce (SUB < BIT_AND).
    Conflict between rule 9 and token MUL resolved as reduce (MUL < BIT_AND).
    Conflict between rule 9 and token DIV resolved as reduce (DIV < BIT_AND).
    Conflict between rule 9 and token MOD resolved as reduce (MOD < BIT_AND).
    Conflict between rule 9 and token BIT_AND resolved as reduce (%left BIT_AND).
    Conflict between rule 9 and token BIT_OR resolved as shift (BIT_AND < BIT_OR).
    Conflict between rule 9 and token LOGIC_AND resolved as shift (BIT_AND < LOGIC_AND).
    Conflict between rule 9 and token LOGIC_OR resolved as shift (BIT_AND < LOGIC_OR).


state 25

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, RP]
    8           | expression BIT_OR expression .  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, RP]
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression

    LOGIC_AND  shift, and go to state 16
    LOGIC_OR   shift, and go to state 17

    $default  reduce using rule 8 (expression)

    Conflict between rule 8 and token ADD resolved as reduce (ADD < BIT_OR).
    Conflict between rule 8 and token SUB resolved as reduce (SUB < BIT_OR).
    Conflict between rule 8 and token MUL resolved as reduce (MUL < BIT_OR).
    Conflict between rule 8 and token DIV resolved as reduce (DIV < BIT_OR).
    Conflict between rule 8 and token MOD resolved as reduce (MOD < BIT_OR).
    Conflict between rule 8 and token BIT_AND resolved as reduce (BIT_AND < BIT_OR).
    Conflict between rule 8 and token BIT_OR resolved as reduce (%left BIT_OR).
    Conflict between rule 8 and token LOGIC_AND resolved as shift (BIT_OR < LOGIC_AND).
    Conflict between rule 8 and token LOGIC_OR resolved as shift (BIT_OR < LOGIC_OR).


state 26

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression
   11           | expression . LOGIC_AND expression  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, LOGIC_AND, RP]
   11           | expression LOGIC_AND expression .  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, LOGIC_AND, RP]

    LOGIC_OR  shift, and go to state 17

    $default  reduce using rule 11 (expression)

    Conflict between rule 11 and token ADD resolved as reduce (ADD < LOGIC_AND).
    Conflict between rule 11 and token SUB resolved as reduce (SUB < LOGIC_AND).
    Conflict between rule 11 and token MUL resolved as reduce (MUL < LOGIC_AND).
    Conflict between rule 11 and token DIV resolved as reduce (DIV < LOGIC_AND).
    Conflict between rule 11 and token MOD resolved as reduce (MOD < LOGIC_AND).
    Conflict between rule 11 and token BIT_AND resolved as reduce (BIT_AND < LOGIC_AND).
    Conflict between rule 11 and token BIT_OR resolved as reduce (BIT_OR < LOGIC_AND).
    Conflict between rule 11 and token LOGIC_AND resolved as reduce (%left LOGIC_AND).
    Conflict between rule 11 and token LOGIC_OR resolved as shift (LOGIC_AND < LOGIC_OR).


state 27

    3 expression: expression . ADD expression
    4           | expression . SUB expression
    5           | expression . MUL expression
    6           | expression . DIV expression
    7           | expression . MOD expression
    8           | expression . BIT_OR expression
    9           | expression . BIT_AND expression
   10           | expression . LOGIC_OR expression  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, LOGIC_AND, LOGIC_OR, RP]
   10           | expression LOGIC_OR expression .  [$end, ADD, SUB, MUL, DIV, MOD, BIT_AND, BIT_OR, LOGIC_AND, LOGIC_OR, RP]
   11           | expression . LOGIC_AND expression

    $default  reduce using rule 10 (expression)

    Conflict between rule 10 and token ADD resolved as reduce (ADD < LOGIC_OR).
    Conflict between rule 10 and token SUB resolved as reduce (SUB < LOGIC_OR).
    Conflict between rule 10 and token MUL resolved as reduce (MUL < LOGIC_OR).
    Conflict between rule 10 and token DIV resolved as reduce (DIV < LOGIC_OR).
    Conflict between rule 10 and token MOD resolved as reduce (MOD < LOGIC_OR).
    Conflict between rule 10 and token BIT_AND resolved as reduce (BIT_AND < LOGIC_OR).
    Conflict between rule 10 and token BIT_OR resolved as reduce (BIT_OR < LOGIC_OR).
    Conflict between rule 10 and token LOGIC_AND resolved as reduce (LOGIC_AND < LOGIC_OR).
    Conflict between rule 10 and token LOGIC_OR resolved as reduce (%left LOGIC_OR).
